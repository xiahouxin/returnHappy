# 垃圾回收（下面讲的是V8引擎的垃圾回收机制）
手动回收：C/C++


自动回收：JavaScript  Java  Python



栈中的垃圾数据是怎么回收的: ESP指针下移，让上一个函数的执行上下文变成无效内存（出栈）

堆中的垃圾数据是怎么回收的：垃圾回收器（垃圾回收器划分为新生代区域和老生代区域）



代际假说： 
1. 大部分对象在内存中存在的时间很短
2. 不死的对象会活的更久


分代收集




新生代区域：存放生存时间短的对象，副垃圾回收器。

老生代区域：存放生存时间长的对象，主垃圾回收器



垃圾回收器的工作流程：
1. 标记空间中活动对象和非活动对象
2. 回收非活动对象所占据的内存
3. 内存整理


新生区回收：使用Scavenge算法：将新生代区域划分为对象区域和空闲区域，新分配的对象第一时间放到对象区域，当对象区域快被装满的时候，就需要一个垃圾回收的机制进行垃圾回收，就是标记空间中活动对象和非活动对象，回收非活动对象所占据的内存，然后将还存在的对象挪到空闲区域中并且整理好，使之不会出现内存片段（内存整理），最后对象区域和空闲区域角色翻转。

在新生代区域经历了两次回收后还存活的对象，会被移动到老生区中（对象晋升策略）（新生代区域如果内存设置较大，在垃圾回收的过程中就会消耗时间较长，进而影响性能，所以新时代区域内存设置的较小，但内存较小很容易被一直存活的对象塞满，所以js引擎为了解决这个问题采取的一个策略）。

老生区的回收：使用Mark-Sweep算法进行遍历标记-清除，标记-整理


 - 全停顿
 js运行在主线程上，当垃圾回收机制生效时，js要暂停运行，将线程让出来，等到垃圾回收完毕，js再继续执行

 增量标记算法（将垃圾回收过程分成几个子过程，然后让子过程和js逻辑代码交替执行） ---- 来优化全停顿带来的页面卡顿