# 按位与（&）  1111111111111111111
按位与（&）运算符在两个操作数对应的二进位都为 1 时，该位的结果值才为 1。（每一位都为 1，结果才为 1）
任何数字 x 与 0 进行按位与运算都会得到 0。
- 观察这个运算：n & (n−1)，其运算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。

# 按位非（~）  222222222222222222
按位非运算符（~）将操作数的位反转。如同其他位运算符一样，它将操作数转化为 32 位的有符号整型。
按位非运算时，任何数字 x 的运算结果都是 -(x + 1)。例如，~-5 运算结果为 4。

# 按位或（|） 3333333333333333333
按位或（|）运算符在其中一个或两个操作数对应的二进制位为 1 时，该位的结果值为 1。（其中一位为 1，结果就是 1）
将任何数字 x 与 0 进行按位或运算得到 x。

# 左移 (<<)  4444444444444444444
左移操作符 (<<) 将第一个操作数向左移动指定位数，左边超出的位数将会被清除，右边将会补零。
移动任意数字 x 至左边 y 位，得出 x * 2 ** y。 所以例如：9 << 3 等价于 9 * 2³ = 9 * 8 = 72

# 右移 (>>)  555555555555555555
右移操作符 (>>) 是将一个操作数按指定移动的位数向右移动，右边移出位被丢弃，左边移出的空位补符号位（最左边那位）。
- 正数右移y位相当于除于2**y并向下取整

# 按位异或（^） 666666666666666666
按位异或（^）运算符在两个操作数有且仅有一个对应的二进制位为 1 时，该位的结果值为 1。（每一位都不同，结果才为 1）
将任意数字 x 与 0 进行按位异或运算得到 x。相等的两数按位异或为0.

从以上代码中可以发现按位异或就是不进位加法

# 面试题：两个数不使用四则运算得出和

这道题中可以按位异或，因为按位异或就是不进位加法，8 ^ 8 = 0 如果进位了，就是 16 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 1 的位置，左边应该有一个进位 1，所以可以得出以下公式 a + b = (a ^ b) + ((a & b) << 1) ，然后通过迭代的方式模拟加法

function sum(a, b) {
    if (a == 0) return b
    if (b == 0) return a
    let newA = a ^ b
    let newB = (a & b) << 1
    return sum(newA, newB)
}